import pandas as pd
from pyspark.sql import DataFrame
from pyspark.sql.functions import col, concat_ws, collect_list, lit, when, count, col, pandas_udf, PandasUDFType
import os
import json
from typing import Dict, Any
from openai import OpenAI
from openai.types.chat.chat_completion import Choice, ChatCompletion, ChatCompletionMessage
from src.dbxmetagen.config import MetadataConfig
from src.dbxmetagen.metadata_generator import PIResponse, MetadataGeneratorFactory
from src.dbxmetagen.error_handling import exponential_backoff


class TableCommentSummarizer:
    def __init__(self, config, df):
        self.config = config
        self.df = df

    def _parse_table_comment_input(df):
        return df.toPandas().to_dict(orient='records')

    def _get_chat_completion(self, config: MetadataConfig, prompt_content: str, model: str, max_tokens: int, temperature: float, retries: int = 0, max_retries: int = 3) -> ChatCompletion:
        base_url=os.environ["DATABRICKS_HOST"] + "/serving-endpoints"
        # TODO: Replace the open AI chat completion with a langchain structured output
        # self.chat_response = ChatDatabricks(
        #     endpoint=self.config.model,
        #     temperature=self.config.temperature,
        #     max_tokens=self.config.max_tokens
        # ).with_structured_output(CommentResponse).invoke(prompt_content)
        # return self.chat_response
        client = OpenAI(api_key=os.environ['DATABRICKS_TOKEN'], base_url=base_url)
        try:
            return client.chat.completions.create(
                messages=prompt_content,
                model=model,
                max_tokens=max_tokens,
                temperature=temperature
            )
        except Exception as e:
            if retries < max_retries:
                print(f"Error: {e}. Retrying in {2 ** retries} seconds...")
                exponential_backoff(retries)
                return self._get_chat_completion(config, prompt_content, model, max_tokens, temperature, retries + 1, max_retries)
            else:
                print(f"Failed after {max_retries} retries.")
                raise e

    def _parse_response(self, response: str) -> Dict[str, Any]:
        print("summary completion response", response)

        try:
            response_dict = json.loads(response)
            if not isinstance(response_dict, dict):
                raise ValueError("Response is not a valid dict")
            return response_dict
        except json.JSONDecodeError as e:
            raise ValueError(f"JSON decode error: {e}")

    def summarize_comments(self, table_name: str) -> str:
        print("Column names...", self.df.columns)
        table_df = self.df.filter(self.df['table'] == table_name)
        comments = table_df.select(concat_ws(" ", collect_list("column_content")).alias("all_comments")).collect()[0]["all_comments"]
        prompt_content = [
            {
                "role": "system",
                "content": f"""You are an excellent AI assistant trying to help summarize multiple incomplete table summaries into one larger summary. You have significant experience at this and have been carefuly trained and tuned to make sure that you are as good as possible at providing high quality descriptions. All of the descriptions come from a single table, and were generated by a series of models. Please follow these instructions:

                ###
                Instructions:

                1. Please focus on the description of the table. Include descriptions of the types of columns, primary keys, foreign keys, and any other information that you can think of.
                2. Please generate between 100 and 500 words, and 1 paragraph. But if you have significant information to include, not just guesses, add more information. The more columns the table has, the more meaningful metadata you are presented with, and if you are presented with significant information about the data in the tables, then spend more time elaborating, but if there is little to work with, then be more brief.
                3. Please make sure you use complete sentences.
                4. Do not include any violent, offensive, racist, or sexually explicit content.
                5. Focus on generating meaningful content that is useful to users of a database table, rather than guessing or generating filler content.
                6. Please review your response for hallucinations and duplication, and be very careful not to duplicate sentences or paragraphs, and be careful not to allow hallucinations to be provided as content.
                7. Please use language implying certainty and facts when you have facts, and implying uncertainty when you have uncertainty.
                8. Do not make any statements like "However, without more detailed information about the table's schema and content it is difficult to provide a more specific description of its structure and potential uses." You have all the information that you need to provide as meaningful a description of the table's structure and potential uses as possible.
                9. Try to only include information that actively adds value. Avoid repeating information, do not include relevant information, and avoid verbose language. 
                10. Be concise unless verbosity is truly warranted.
                """
            },
            {
                "role": "user",
                "content": f"{comments}"
            }
        ]
        chat_completion = self._get_chat_completion(self.config, prompt_content, model=self.config.model, max_tokens=5000, temperature=0.7)
        print("Chat completion response...", chat_completion)
        response_content = chat_completion.choices[0].message.content
        return response_content
