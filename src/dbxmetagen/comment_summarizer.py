import pandas as pd
from pyspark.sql import DataFrame
from pyspark.sql.functions import col, concat_ws, collect_list, lit, when, count, col, pandas_udf, PandasUDFType
import os
import json
from typing import Dict, Any
from openai import OpenAI
from openai.types.chat.chat_completion import Choice, ChatCompletion, ChatCompletionMessage
from src.dbxmetagen.config import MetadataConfig
from src.dbxmetagen.metadata_generator import PIResponse, MetadataGeneratorFactory
from src.dbxmetagen.error_handling import exponential_backoff


class TableCommentSummarizer:
    def __init__(self, config, df):
        self.config = config
        self.df = df

    def _parse_table_comment_input(df):
        return df.toPandas().to_dict(orient='records')

    def _get_chat_completion(self, config: MetadataConfig, prompt_content: str, model: str, max_tokens: int, temperature: float, retries: int = 0, max_retries: int = 3) -> ChatCompletion:
        base_url=os.environ["DATABRICKS_HOST"] + "/serving-endpoints"
        client = OpenAI(api_key=os.environ['DATABRICKS_TOKEN'], base_url=base_url)
        try:
            return client.chat.completions.create(
                messages=prompt_content,
                model=model,
                max_tokens=max_tokens,
                temperature=temperature
            )
        except Exception as e:
            if retries < max_retries:
                print(f"Error: {e}. Retrying in {2 ** retries} seconds...")
                exponential_backoff(retries)
                return self._get_chat_completion(config, prompt_content, model, max_tokens, temperature, retries + 1, max_retries)
            else:
                print(f"Failed after {max_retries} retries.")
                raise e

    def _parse_response(self, response: str) -> Dict[str, Any]:
        print("summary completion response", response)

        try:
            response_dict = json.loads(response)
            if not isinstance(response_dict, dict):
                raise ValueError("Response is not a valid dict")
            return response_dict
        except json.JSONDecodeError as e:
            raise ValueError(f"JSON decode error: {e}")

    def summarize_comments(self, table_name: str) -> str:
        print("Column names...", self.df.columns)
        table_df = self.df.filter(self.df['table'] == table_name)
        comments = table_df.select(concat_ws(" ", collect_list("column_content")).alias("all_comments")).collect()[0]["all_comments"]
        prompt_content = [
            {
                "role": "system",
                "content": f"""You are an AI assistant trying to help summarize multiple incomplete table summaries into one larger summary. All of the descriptions come from a single table, and were generated by a series of models. Please follow these instructions:

                ###
                Instructions:

                1. Please focus on the description of the table. Include descriptions of the types of columns, primary keys, foreign keys, and any other information that you can think of.
                2. Please generate between 100 and 500 words and between 1 to 3 paragraphs.
                3. Please make sure you use complete sentences.
                4. Do not include any violent, offensive, racist, or sexually explicit content."""
            },
            {
                "role": "user",
                "content": f"{comments}"
            }
        ]
        chat_completion = self._get_chat_completion(self.config, prompt_content, model=self.config.model, max_tokens=5000, temperature=0.7)
        print("Chat completion response...", chat_completion)
        #response_content = self._parse_response(chat_completion.choices[0].message.content)
        response_content = chat_completion.choices[0].message.content
        return response_content
